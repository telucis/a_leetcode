> size : 76+29

* tree
    - stack
        + **二叉树的前序遍历  144**
        + **二叉树的中序遍历  94**
        + **二叉树的后序遍历  145**
        + 二叉搜索树迭代器  173
        + 序列化和反序列化二叉搜索树  449
    - 根据前序和后序遍历构造二叉树  889
    - 从先序遍历还原二叉树  1028
    - 二叉树的序列化与反序列化  297
    - path
        + 二叉树中的最大路径和  124  (helper返回root点出发的最大路径) 
        + 最长同值路径  687  (各节点独立计算)
        + 二叉树的直径  543
        + 在二叉树中分配硬币  979  (中间状态[new int[]{节点数, 金币数}])
        + 路径总和III  437  (各节点独立计算)
    - traversal_mid
        + 寻找重复的子树  652  (map序列化存储)
        + 翻转二叉树以匹配先序遍历  971  (先序遍历)
        + 出现次数最多的子树元素和  508  (map存子树和次数)
        + 输出二叉树  655
        + 从叶结点开始的最小字符串  988  (注意：加suffix)
    + divideConquer_mid
        + 在二叉树中增加一行  623
        + 二叉树减枝  814  (删除全为0子树)
        + 所有可能的满二叉树  894
        + 完全二叉树的节点个数  222  (完全二叉树特性)
        + 翻转等价二叉树  951
        + 二叉树的最近公共祖先  236
        + 节点与其祖先之间的最大差值  1026  (中间状态[new int[ans, min, max]])
        + 具有所有最深结点的最小子树  865  (中间状态[depth])
    - finish
        + pathProblem
            * 二叉树的所有路径  257  
            * 路径总和  112
            * 路径总和II  113
            * 求根到叶子节点数字之和  129
        + bst_mid
            * 删除二叉搜索树中的节点  450
            * 二叉搜索树中的插入操作  701
            * 二叉搜索树中第K小的元素  230  (follow up:频繁修改、频繁查询)
            * 不同的二叉搜索树  96  (记忆化搜索)
            * 不同的二叉搜索树II  95
            * 验证二叉搜索树  98  (中间状态[new int[]{1, ll, rr}])
        + bst_easy
            * 把二叉搜索树转换为累加树  538
            * 从二叉搜索树到更大和树. 1038. (同538)
            * 将有序数组转换为二叉搜索树  108
            * 二叉搜索树中的众数  501
            * 二叉搜索树的最近公共祖先  235
            * 二叉搜索树的最小绝对差  530
            * 二叉搜索树结点最小距离. 783  (同530)
            * 二叉搜索树的范围和. 938
            * 二叉搜索树中的搜索. 700
            * 修剪二叉搜索树. 669
        + traversal_easy
            * 二叉树的堂兄弟节点  993
            * 从根到叶的二进制数之和  1022
        + nAryTree
            * N叉树的最大深度  559
            * N叉树的层序遍历  429
            * N叉树的后序遍历  590
            * N叉树的前序遍历  589
         + quadTree
            * 建立四叉树  427
            * 四叉树交集  558
        + constructTree
            * 从中序与后序遍历序列构造二叉树  106
            * 先序遍历构造二叉树  1008  (bst)
            * 从前序与中序遍历序列构造二叉树  105
            * 最大二叉树  654
            * 最大二叉树II  998
            * 恢复二叉搜索树  99
        + divideConquer_easy
            * 平衡二叉树  110
            * 二叉树的坡度  563  (坡度：左节点和与右节点和差绝对值，求所有坡度之和)
            * 根据二叉树创建字符串  606  (注意：省略的括号)
            * 递增顺序查找树  897  (中序遍历树转链)
            * 二叉树展开为链表  114  (前序遍历树转链)
            * 翻转二叉树  226
            * 叶子相似的树  872
            * 二叉树的最大深度  104
            * 二叉树的最小深度  111  (注意：depth=0情况)
            * 合并二叉树  617
            * 相同的树  100
            * 左叶子之和  404  (注意：加isLeft参数)
            * 对称二叉树  101  (注意：分两个节点比较)
            * 单值二叉树  965
            * 二叉树中第二小的节点  671
            * 另一个树的子树  572
* link
    - **反转链表  206**
    - **反转链表II  92**
    - **排序链表  148**
    - 奇偶链表  328  (链表partitionj)
    - finish
        + slowFast
            * 环形链表  141
            * 环形链表II  142
            * 有序链表转换二叉搜索树  109
            * 删除链表的倒数第N个节点  19
            * 链表的中间结点  876
        + reverse
            * k个一组翻转链表  25
            * 回文链表  234
            * 重排链表  143
        + traversal
            * 删除链表中的节点  237  (改变节点val)
            * 扁平化多级双向链表  430
            * 相交链表  160
            * 链表组件  817
            * 合并两个有序链表  21
            * 删除排序链表中的重复元素  83
            * 删除排序链表中的重复元素II  82
            * 移除链表元素  203
            * 旋转链表  61
            * 两两交换链表中的节点  24
            * 两数相加  2
            * 两数相加II  445
        + sort
            * 复制带随机指针的链表  138
            * 对链表进行插入排序  147
            * 合并K个排序链表  23  (heap)
            * 分隔链表  725
            * 分隔链表  86  (链表partition)


