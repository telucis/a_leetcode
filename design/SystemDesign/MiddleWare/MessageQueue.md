### 使用场景

* 业务解耦
* 最终一致性 (强一致性RPC更合适)
* 广播
* 错峰流控

### 队列的本质

* 一次RPC转两次RPC
    - 数据流：**producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等**
    - 利用RPC将数据流串起来，然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展
* 内容转储
    - 承载消息堆积，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素
* 选择合适时机投递

### 设计重点

* RPC通信协议
* 存储选型
    - 持久化/非持久化
    - 速度：**文件系统>分布式KV（持久化）>分布式文件系统>数据库**，可靠性相反
* 消费关系处理
    - **组间广播、组内单播**，消息需要通知到多个业务集群，而一个业务集群内有很多台机器，只要一台机器消费这个消息就可以
    - 组内的广播的有适用场景：本地缓存的更新
    - 广播关系的维护，一般在公共存储上，如config server、zookeeper等
        + 发送关系的维护。
        + 发送关系变更时的通知
* 实现事务
* 防丢/防重
* 批量/异步与性能

### push/pull模式

* 慢消费
    - 慢消费无疑是push模型最大的致命伤，穿成流水线来看，如果消费者的速度比发送者的速度慢很多，势必造成消息在broker的堆积。假设这些消息都是有用的无法丢弃的，消息就要一直在broker端保存。当然这还不是最致命的，最致命的是broker给consumer推送一堆consumer无法处理的消息，consumer不是reject就是error，然后来回踢皮球。
    - 反观pull模式，consumer可以按需消费，不用担心自己处理不了的消息来骚扰自己，而broker堆积消息也会相对简单，无需记录每一个要发送消息的状态，只需要维护所有消息的队列和偏移量就可以了。所以对于建立索引等慢消费，消息量有限且到来的速度不均匀的情况，pull模式比较合适。
* 消息延迟与忙等
    - 这是pull模式最大的短板。由于主动权在消费方，消费方无法准确地决定何时去拉取最新的消息。
        + 1. 指数级增长等待
        + 2. 长轮询: 如果尝试拉取失败，不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来，把连接notify起来
* 顺序消息
    - push比较难处理
        + 支持分区，单分区只支持一个消费者消费，并且消费者只有确认一个消息消费后才能push送另外一个消息，还要发送者保证全局顺序唯一
    - pull处理比较简单
        + producer对应partition，并且单线程。
        + consumer对应partition，消费确认（或批量确认），继续消费即可。



