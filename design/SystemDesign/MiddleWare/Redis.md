### 高效的原因

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CP，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路I/O复用模型，非阻塞IO；
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### 高可用 （持久化、复制、哨兵、集群）

* 哨兵模式
    - 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
    - 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。
* 多哨兵模式 - 故障切换（failover）的过程
    - 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为 **主观下线**
    - 当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作
    - slave之间采用 **raft**算法选举出一个master节点
    - 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 **客观下线**

* RDB
    - 优点：
        + RDB 是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。 
        + RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
        + RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
    - 缺点：
        + RDB是一个快照过程，无法完整的保存所有数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。
        + 当redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。
        + RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。
* AOF
    - 优点：
        + 数据更完整，秒级数据丢失(取决于设置fsync策略)。
        + 兼容性较高，由于是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。
    - 缺点：
        + 数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。
        + 相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。
        + 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。
* 混合持久化
    - 优点：
        + 混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。
    - 缺点：
        + 兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差

* 主从复制
    - 复制初始化阶段
    - 数据同步阶段
        + 主库和从库都确认对方信息以后，便可开始数据同步，此时从库向主库发送psync命令(需要注意的是redis4.0版本对2.8版本的psync做了优化)
        + 主库收到该命令后判断是进行增量复制还是全量复制，然后根据策略进行数据的同步，当主库有新的写操作时候，此时进入复制第三阶段：命令传播阶段。
    - 命令传播阶段
        + 当数据同步完成以后，在此后的时间里主从维护着心跳检查来确认对方是否在线，每隔一段时间（默认10秒，通过repl-ping-slave-period参数指定）主节点向从节点发送PING命令判断从节点是否在线，而从节点每秒1次向主节点发送REPLCONF ACK命令，命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量，作用一是汇报自己复制偏移量，主节点会对比复制偏移量向从节点发送未同步的命令，作用二在于判断主节点是否在线，从库接送命令并执行，最终实现与主库数据相同。
    - 乐观复制
        + redis采用量乐观复制策略，容忍在一定时间内主从数据内容是不同的，但是两者的数据最终会同步。

### 缓存穿透预防及优化

* 缓存空对象
    - 适用场景
        + 数据命中率不高
        + 数据频繁变化
    - 维护成本
        + 代码简单
        + 需要过多的存储空间(设置过期时间)
        + 数据不一致(异步处理)
* 布隆过滤器
    - 适用场景
        + 数据命中率不高
        + 数据相对固定，实时性低
    - 维护成本
        + 代码复制
        + 占用较小的空间
        
### 缓存雪崩问题优化

* 保证缓存层服务高可用性
    - Redis Sentinel 和 Redis Cluster 
* 依赖隔离组件为后端限流并降级
    - 对重要的资源 ( 例如 Redis、 MySQL、 Hbase、外部接口 ) 都进行隔离
    - 服务降级，对高A低C服务做降级处理
* 故障演练/全链路压测
    - 演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。

### 缓存热点 key 重建优化

* 分布式锁
    - 优点
        + 思路简单，保持一致性
    - 缺点
        + 代码复制度大
        + 存在死锁风险
        + 存在线程池阻塞风险
* 永不过期
    - 优点
        + 基本杜绝热点key问题
    - 缺点
        + 不保证一致性
        + 逻辑过期时间增加代码维护成本和内存成本

### 缓存的更新策略

* Cache Aside
    - 先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效
* Read/Write Through
    - 应用要读数据和更新数据都直接访问缓存服务
    - 缓存服务同步的将数据更新到数据库
* Write Behind
    - 应用要读数据和更新数据都直接访问缓存服务
    - 缓存服务异步的将数据更新到数据库（通过异步任务）

### 分布式锁

* DB锁
    - 数据库新建一张表用于控制并发控制
* Redis锁
    - `set key_id key_value NX PX expireTime`
    - 问题：如果一个获取到锁的client因为某种原因导致没能及时释放锁，并且redis因为超时释放了锁，另外一个client获取到了锁
* ZK锁
    - 对同一个path并发多个创建请求时，只有一个client能创建成功


